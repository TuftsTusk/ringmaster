// Plugins
var uuid = require('uuid')
express = require('express'),
path = require('path'),
favicon = require('serve-favicon'),
logger = require('morgan'),
cors = require('cors'),
MongoClient = require('mongodb').MongoClient,
format = require('util').format,
cookieParser = require('cookie-parser'),
bodyParser = require('body-parser'),
mongoose = require('mongoose'),
validator = require('validator'),
bcrypt = require('bcrypt-nodejs'),
mailer = require('nodemailer');

// load Schema
var Listings = require('./models/listing.js');
var Unconf_User = require('./models/unconf_user.js');
var User = require('./models/user.js');

// Tusk Libraries
var Validate = require('./lib/validation.js');
var Utils = require('./lib/utils.js');
var Consts = require('./lib/consts.js');

// Configuration
var app = express();
app.use(logger('dev'));
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: false }));
app.use(cookieParser());
app.use(express.static(path.join(__dirname, 'public')));
app.set('view engine', 'jade');

// Tusk Routes
var UserRoutes = require('./route/user.js');


var ENV = Consts.ENV;
var UNDEF = Consts.UNDEF;
var UNKWN = Consts.UNKWN;
var DEV = Consts.DEV;
var STG = Consts.STG;
var PROD = Consts.PROD;
/* Possible values:
 *   undefined - NODE_ENV is not set. This should be treated as a FATAL error.
 * development - Development environment, enable debug logging, etc.
 *     staging - Staging server, perhaps allowing additional test code or authentication.
 *  production - Live, production environment that is public-facing. No debug output!
 */
if (ENV < 0) {
    if (ENV === UNDEF)
        console.log("NODE_ENV variable not set. App will not execute until it is assigned a value.");
    if (ENV === UNKWN)
        console.log("NODE_ENV variable assigned to an unrecognized value.");
    console.log("Possible values: development, staging, production");
    process.exit(1);
}

function log(obj) {
    if (ENV === DEV || ENV === STG) {
        console.log(obj);
    }
}

var whitelist = ['http://localhost:8080', 'https://tuskdumbo.herokuapp.com', 'http://tuskmarketplace.com', 'https://tuskmarketplace.com', 'https://tuskdumbostaging.herokuapp.com'];
var corsOptions = {
  origin: function(origin, callback){
    var originIsWhitelisted = whitelist.indexOf(origin) !== -1;
    callback(null, originIsWhitelisted);
  }
};
app.use(cors({credentials: true, origin: true}));

app.options('*', cors(corsOptions));

// Session related plugins
var session = require('express-session');
var MongoStore = require('connect-mongo')(session);

// Database
var mongoUri = process.env.MONGOLAB_URI || process.env.MONGOHQ_URL || 'mongodb://localhost/tusk';
mongoose.connect(mongoUri);

app.use(session({
    secret: 'tuskislovetuskislife',
    cookie: {
        expires: Consts.genDefaultExpires(),
        maxAge: Consts.getDefaultMaxAge()
    },
    saveUninitialized: false,
    resave: true,
    rolling: true,
    unset: 'destroy',
    store: new MongoStore({
        mongooseConnection: mongoose.connection
    })
}));

if (ENV === DEV || ENV === STG)
    app.get('/users', function(request, response) {
        response.set('Content-Type', 'application/json');
        User.find({}, function(err, users) {
            if (!err) {
                return response.status(200).send(JSON.stringify({
                    users: users
                }));
            } else
                return sendEnvConfigFailure(response);
        });
    });



/*
 *   Method | GET
 *
 *    Route | /user/:id/confirm
 *
 *   Params | :id - mongo id of unconf_user account
 *          | key - confirmation key as generated by /user/register
 *
 * Response | success | {success: true, message: String}
 *          | failure | {success: false, type: ErrString, message: String}
 *
 *   Errors | INVALID_USER_ID - No unconfirmed user with that id was found
 *          | DISK_SAVE_FAILURE - A confirmed user account could not be saved to disk
 *          | INVALID_CONFIRMATION_KEY - The provided confirmation key did not match
 *                                         that on file for that user
 */
app.get('/user/:id/confirm', function(request, response) {
    return UserRoutes.getUserConfirmById(request, response);
});

/*
 *   Method | POST
 *
 *    Route | /user/register
 *
 *   Params | email - email as provided by the user
 *          | password - password as provided by the user
 *          | confirmpass - confirm password as provided
 *
 * Response | success | {success: true, message: String}
 *          | failure | {success: false, type: ErrString, message: String}
 *
 *   Errors | MISSING_REGISTRATION_FIELD_FAILURE - One of the params was missing
 *          | TUFTS_EMAIL_VALIDATION_FAILURE - The email used for registration was not a valid Tufts email
 *          | EMAIL_IN_USE_FAILURE - The email used for registration was already in use
 *          | PASSWORD_MISMATCH_FAILURE - The password and confirmpass fields did not match
 *          | DISK_SAVE_FAILURE - The user account failed to save to disk
 */
app.post('/me/register', function(request, response) {
    return UserRoutes.postMeRegister(request, response);
});

/*
 *   Method | POST
 *
 *    Route | /user/logout
 *
 *   Params | none
 *
 * Response | success | {success: true, message: String}
 *          | failure | {success: false, type: ErrString, message: String}
 *
 *   Errors | LOGIN_SESSION_NOT_FOUND_FAILURE - The user was either not logged in or they had
 *                                                an invalid session cookie
 */
app.post('/me/logout', function(request, response) {
    return UserRoutes.postMeLogout(request, response);
});

if (ENV === DEV || ENV === STG) {
    app.delete('/unconf_user/:email', function(request, response) {
        Unconf_User.findOneAndRemove({email:Validate.normalizeEmail(request.params.email)}, function(err, resp) {
            if (err || !resp) {
                return response.status(500).send(error('UNCONF_USER_DELETION_FAILURE', 'An unconfirmed user account failed to be deleted'));
            } else {
                return response.sendStatus(204);
            }
        });
    });

    app.delete('/user/:email', function(request, response) {
        User.findOneAndRemove({email:request.params.email}, function(err, user) {
            if (err || !user) {
                return reponse.status(404).send();
            } else {
                return response.sendStatus(204);
            }
        });
    });

    app.delete('/all', function(request, response) {
        User.remove({});
        Unconf_User.remove({});
        Listing.remove({});
        response.sendStatus(204)
    });
}

/*
 *   Method | POST
 *
 *    Route | /user/login
 *
 *   Params | none
 *
 * Response | success | {success: true, message: String}
 *          | failure | {success: false, type: ErrString, message: String}
 *
 *   Errors | LOGIN_SESSION_NOT_FOUND_FAILURE - The user was either not logged in or they had
 *                                                an invalid session cookie
 */
app.post('/me/login', function(request, response) {
    return UserRoutes.postMeLogin(request, response);
});

app.put('/me/password', function(request, response) {
    request.params.targetid = request.session.login.who.id;
    return UserRoutes.putUserPasswordById(request, response);
});

app.post('/user/:email/recover', function(request, response) {
    return UserRoutes.postUserRecoverByEmail(request, response);
});

app.get('/alive', function(request, response){
  return response.send('yes thank you');
});

function error(type, message) {
    return JSON.stringify({
        type: type,
        message: message
    });
}

function sendEnvConfigFailure(response) {
    return response.status(500).send(error(
        'ENVIRONMENT_MISCONFIGURATION_FAILURE',
        'The local environment was configured incorrectly'
    ));
}

function sendNotYetImplementedFailure(response) {
    return response.status(501).send(error('NOT_YET_IMPLEMENTED_FAILURE', 'Not yet implemented'));
}

function ensureLoginSession(request) {
    if (request.session.login &&
        request.session.login.valid &&
        request.session.login.who.id) {
        return true;
    }
    return false;
}

function makeNewListingFromPost(body, user_id) {
    if (body.type) {
        if (body.type === Listings.MISC) {
            var miscListing = new Listings.MiscListing;
            miscListing.title = body.title;
            miscListing.body = body.body;
            miscListing.user_id = user_id;
            return {
                type: Listings.MISC,
                listing: miscListing
            };
        }
    }
    return false;
}

app.route('/listing')
    .post(function(request, response) {
        response.set('Content-Type', 'application/json');

        if (!ensureLoginSession(request)) {
            return response.status(400).send(error(
                'NOT_LOGGED_IN_EXCEPTION',
                'Listing could not be posted because the user is not logged in'
            ));
        }
        
        var newListing = makeNewListingFromPost(request.body, request.session.login.who.id);
        if (!newListing) {
            return response.status(400).send(JSON.stringify({
                type: 'LISTING_INVALID_DATA_EXCEPTION',
                message: 'Listing data did not contain all requisite fields'
            }));
        } else {
            newListing.listing.save(function (err) {
                if (!err) {
                    return response
                            .status(201)
                            .set('Location', '/listing/'+newListing.listing._id)
                            .send({rsc_id: newListing.listing._id});
                } else {
                    return response.status(500).send(error('DISK_SAVE_FAILURE', err));
                }
            });
        }
    })
    .get(function(request,response){
      response.set('Content-Type', 'application/json');
         return Listings.Listing.find(function (err, listings) {
            if (!err){
              return response.status(200).send(listings.reverse());
            } else {
              return response.status(404).send('{}');
            }
        });
    });

app.get('/search/:vars/:val', function(request,response){
  response.set('Content-Type', 'application/json');
	var val = request.params.val;
	return Listings.Listing.find({_id:val}, function (err, listing) {
	    if (!err){
	        response.status(200).send(JSON.stringify({
                listing: listing
            }));
	    } else {
	      response.status(404).send('{}');
	    }
	});
});

app.get('/listing/:uid', function(request,response){
  response.set('Content-Type', 'application/json');
	var uid = request.params.uid;
	return Listing.Listing.find({_id:uid}, function (err, listing) {
	    if (!err){
	        response.status(200).send(JSON.stringify({
                listing: listing
            }));
	    } else {
            response.status(404).send('{}');
	    }
	});
});

if (ENV === DEV || ENV === STG) {
    app.delete('/listing/:uid', function(request,response){
        var uid = request.params.uid;
        return Listings.Listing.findOneAndRemove({_id:uid}, function (err, listing) {
            if (!err && listing) {
                response.sendStatus(204);
            } else {
                return response.status(500).send(error(
                    'UNKNOWN_SERVER_FAILURE',
                    err
                ));
            }
        });
    });
}

function purgeSession(response) {
    response.clearCookie('connect.sid');

}

// catch 404 and forward to error handler
app.use(function(req, res, next) {
  var err = new Error('Not Found');
  err.status = 404;
  next(err);
});

// error handlers

// TODO: check up on this
// development error handler
// will print stacktrace
if (app.get('env') === 'development') {
  app.use(function(err, req, res, next) {
    res.status(err.status || 500);
    res.render('error', {
      message: err.message,
      error: err
    });
  });
}


// production error handler
// no stacktraces leaked to user
app.use(function(err, req, res, next) {
  res.status(err.status || 500);
  res.render('error', {
    message: err.message,
    error: {}
  });
});


app.listen(process.env.PORT || 80);

module.exports = app;
