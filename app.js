// Plugins
var uuid = require('uuid')
express = require('express'),
path = require('path'),
favicon = require('serve-favicon'),
logger = require('morgan'),
cors = require('cors'),
MongoClient = require('mongodb').MongoClient, format = require('util').format,
cookieParser = require('cookie-parser'),
bodyParser = require('body-parser'),
mongoose = require('mongoose'),
validator = require('validator'),
bcrypt = require('bcrypt-nodejs'),
mailer = require('nodemailer');

// load Schema
var MiscListing = require('./models/misc_listing.js');
var SubletListing = require('./models/sublet_listing.js');
var Unconf_User = require('./models/unconf_user.js');
var User = require('./models/user.js');

// Tusk Libraries
var Validate = require('./lib/validation.js');
var Utils = require('./lib/utils.js');
var Consts = require('./lib/consts.js');

// Configuration
var app = express();
app.use(logger('dev'));
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: false }));
app.use(cookieParser());
app.use(express.static(path.join(__dirname, 'public')));
app.set('view engine', 'jade');

var UNDEF = -1,
    UNKWN = -2,
    DEV   =  0,
    STG   =  1,
    PROD  =  2;

var ENVS = {
    "undefined": UNDEF,
    "unknown": UNKWN,
    "development": DEV,
    "staging": STG,
    "production": PROD
};
var raw_ENV = process.env.NODE_ENV;
var ENV = (raw_ENV in ENVS)?ENVS[raw_ENV]:UNKWN;
/* Possible values:
 *   undefined - NODE_ENV is not set. This should be treated as a FATAL error.
 * development - Development environment, enable debug logging, etc.
 *     staging - Staging server, perhaps allowing additional test code or authentication.
 *  production - Live, production environment that is public-facing. No debug output!
 */
if (ENV < 0) {
    if (ENV === UNDEF)
        console.log("NODE_ENV variable not set. App will not execute until it is assigned a value.");
    if (ENV === UNKWN)
        console.log("NODE_ENV variable assigned to an unrecognized value.");
    console.log("Possible values: development, staging, production");
    process.exit(1);
}

var whitelist = ['http://localhost:8080', 'https://tuskdumbo.herokuapp.com', 'http://tuskmarketplace.com', 'https://tuskmarketplace.com', 'https://tuskdumbostaging.herokuapp.com'];
var corsOptions = {
  origin: function(origin, callback){
    var originIsWhitelisted = whitelist.indexOf(origin) !== -1;
    callback(null, originIsWhitelisted);
  }
};
app.use(cors({credentials: true, origin: true}));

app.options('*', cors(corsOptions));

// Session related plugins
var session = require('express-session');
var MongoStore = require('connect-mongo')(session);

// Database
var mongoUri = process.env.MONGOLAB_URI || process.env.MONGOHQ_URL|| 'mongodb://localhost/tusk';
mongoose.connect(mongoUri);



app.use(session({
    secret: 'tuskislovetuskislife',
    cookie: {
        expires: Consts.genDefaultExpires(),
        maxAge: Consts.getDefaultMaxAge()
    },
    saveUninitialized: false,
    resave: true,
    rolling: true,
    unset: 'destroy',
    store: new MongoStore({
        mongooseConnection: mongoose.connection
    })
}));

/*
 *   Method | GET
 *
 *    Route | /user/:id/confirm
 *
 *   Params | :id - mongo id of unconf_user account
 *          | key - confirmation key as generated by /user/register
 *
 * Response | success | {success: true, message: String}
 *          | failure | {success: false, type: ErrString, message: String}
 *
 *   Errors | INVALID_USER_ID - No unconfirmed user with that id was found
 *          | DISK_SAVE_FAILURE - A confirmed user account could not be saved to disk
 *          | INVALID_CONFIRMATION_KEY - The provided confirmation key did not match
 *                                         that on file for that user
 */
app.get('/user/:id/confirm', function(request, response) {
    response.set('Content-Type', 'application/json');
    Unconf_User.findOne({_id: request.params.id}, function(err, user) {
        if (err) {
            return response.status(400).send(JSON.stringify({
                success: false,
                type: 'INVALID_USER_ID',
                message: 'Invalid user id'
            }));
        } else {
            if (request.query.key === user.confirmationKey) {
                user.remove();

                var newuser = new User;
                newuser.email = user.email;
                newuser.passwordHash = user.passwordHash;
                newuser.passwordSalt = user.passwordSalt;

                newuser.save(function (err) {
                    if (err) {
                        return response.status(400).send(JSON.stringify({
                            success: false,
                            type: 'DISK_SAVE_FAILURE',
                            message: err
                        }));
                    } else {
                        return response.status(200).send(JSON.stringify({
                            success: true,
                            message: 'Account email successfully verified'
                        }));
                    }
                });
            } else {
                return response.status(400).send(JSON.stringify({
                    success: false,
                    type: 'INVALID_CONFIRMATION_KEY',
                    message: 'The confirmation key provided was invalid'
                }));
            }
        }
    });
});

/*
 *   Method | POST
 *
 *    Route | /user/register
 *
 *   Params | email - email as provided by the user
 *          | password - password as provided by the user
 *          | confirmpass - confirm password as provided
 *
 * Response | success | {success: true, message: String}
 *          | failure | {success: false, type: ErrString, message: String}
 *
 *   Errors | MISSING_REGISTRATION_FIELD_FAILURE - One of the params was missing
 *          | TUFTS_EMAIL_VALIDATION_FAILURE - The email used for registration was not a valid Tufts email
 *          | EMAIL_IN_USE_FAILURE - The email used for registration was already in use
 *          | PASSWORD_MISMATCH_FAILURE - The password and confirmpass fields did not match
 *          | DISK_SAVE_FAILURE - The user account failed to save to disk
 */
app.post('/user/register', function(request, response) {
    response.set('Content-Type', 'application/json');
    if (!Validate.checkForKeys(["email", "password", "confirmpass"], request.body)) {
        return response.status(400).send(JSON.stringify({
            success: false,
            type: 'MISSING_REGISTRATION_FIELD_FAILURE',
            message: "One or more of the registration fields was missing"
        }));
    } else {
        var email = Validate.normalizeEmail(request.body.email);
        if (!Validate.validateTuftsEmail(email)) {
            return response.status(400).send({
                success: false,
                type: 'TUFTS_EMAIL_VALIDATION_FAILURE',
                message: 'Email must be a tufts email'
            });
        } else {
            /*
             *  1. Check if the email is currently in use
             *      a. Normalize the email
             *            i. Gmail addresses ignore dots (.) in the email name
             *           ii. Others?
             *      b. If the email is in use, then report as such
             *  2. If the email is not in use, but there is an unverified entry for that email
             *      a. If so, check the timestamp
             *             i. If the existing entry is over 1 hour old, then delete it and
             *                  replace it with a new entry
             *            ii. If the existing entry is less than 1 hour old, report the email
             *                  as recently registered (and re-send the confirmation email?)
             *  3. If the email is not in use, nor is there an unconfirmed account for that email
             *      a. Create an unconfirmed account for that email and send the confirmation
             *          email. Report as such.
             */
            User.findOne({email:email}, function(err, user) {
                if (user) {
                    return response.status(400).send({
                        success: false,
                        type: 'EMAIL_IN_USE_FAILURE',
                        message: 'Email is already in use'
                    });
                }
                var password = request.body.password;
                if (password != request.body.confirmpass) {
                    return response.status(400).send({
                        success: false,
                        type: 'PASSWORD_MISMATCH_FAILURE',
                        message: "Passwords did not match"
                    });
                } else {
                    Unconf_User.findOne({email: email}, function(err, user) {
                        if (user) {
                            var now = (new Date()).getTime();
                            if (user.when.getTime() - now > 60000) {

                            } else {

                            }
                            Unconf_User.remove({email: email});
                        }
                        var newuser = new Unconf_User;

                        newuser.email = email;

                        var salt = bcrypt.genSaltSync(10);

                        newuser.passwordSalt = salt;
                        newuser.passwordHash = bcrypt.hashSync(password, salt);

                        confirmKey = Utils.md5(salt + email);

                        newuser.confirmationKey = confirmKey;

                        //TODO: Generate and send confirmation email
                        //      also create a new model for an unconfirmed user

                        newuser.save(function(err) {
                            if (!err) {
                                return response.status(200).send(JSON.stringify({
                                    success: true,
                                    email: email,
                                    id: newuser._id,
                                    key: confirmKey
                                }));
                            } else {
                                return response.status(400).send(JSON.stringify({
                                    success: false,
                                    type: 'DISK_SAVE_FAILURE',
                                    message: err
                                }));
                            }
                        });
                    });
                }
            });
        }
    }
});

/*
 *   Method | POST
 *
 *    Route | /user/logout
 *
 *   Params | none
 *
 * Response | success | {success: true, message: String}
 *          | failure | {success: false, type: ErrString, message: String}
 *
 *   Errors | LOGIN_SESSION_NOT_FOUND_FAILURE - The user was either not logged in or they had
 *                                                an invalid session cookie
 */
app.post('/user/logout', function(request, response) {
    response.set('Content-Type', 'application/json');
    //ensure client clears their cookies
    response.clearCookie('connect.sid');
    if ('login' in request.session) {
        delete request.session;
        return response.status(200).send(JSON.stringify({success: true, message: 'Successfully logged out'}));
    }
    return response.status(400).send(JSON.stringify({
        success: false,
        type: 'LOGIN_SESSION_NOT_FOUND_FAILURE',
        message: 'Unsuccessfully logged out because not logged in'
    }));
});

// for debug only!!! not a real endpoint!
// TODO: remove these and make a secure access method to perform deletion
app.delete('/unconf_user/:email', function(request, response) {
    response.set('Content-Type', 'application/json');
    Unconf_User.findOneAndRemove({email:Validate.normalizeEmail(request.params.email)}, function(err, resp) {
        if (err || !resp) {
            return response.status(400).send(JSON.stringify({success: false, message:err}));
        } else {
            return response.status(200).send(JSON.stringify({success: true, user:resp}));
        }
    });
});

// for debug only!!! not a real endpoint!
// TODO: remove these and make a secure access method to perform deletion
app.delete('/user/:email', function(request, response) {
    response.set('Content-Type', 'application/json');
    User.find({email:request.params.email}, function(err, user) {
        if (err || !user) {
            return reponse.status(200).send(JSON.stringify({success: false}));
        } else {
            User.findOneAndRemove({email:request.params.email}, function(err, resp) {
                if (err) {
                    return response.status(400).send(JSON.stringify({success: false, message:err}));
                } else {
                    return response.status(200).send(JSON.stringify({success: true, user:resp}));
                }
            });
        }
    });
});

/*
 *   Method | POST
 *
 *    Route | /user/login
 *
 *   Params | none
 *
 * Response | success | {success: true, message: String}
 *          | failure | {success: false, type: ErrString, message: String}
 *
 *   Errors | LOGIN_SESSION_NOT_FOUND_FAILURE - The user was either not logged in or they had
 *                                                an invalid session cookie
 */
app.post('/user/login', function(request, response) {
    response.set('Content-Type', 'application/json');
    if ("login" in request.session && "tries" in request.session.login) {
        var diff = Date.now() - request.session.login.when;
        if (diff > (3 * 60 * 1000))
            delete request.session.login;
        else if (request.session.login.tries > 5) {
            return response.status(400).send(JSON.stringify({success: false, message: "Too many login attempts. Wait a few minutes and try again."}));
        }
    }
    User.findOne({email:request.body.email}, function(err, user) {
        if (err) {
            reponse.status(400).send(JSON.stringify({success: false, message: err}));
        } else {
            if (user && bcrypt.hashSync(request.body.password, user.passwordSalt) === user.passwordHash) {
                request.session.login = {valid: true, when: Date.now()};
                return response.status(200).send(JSON.stringify({success: true, message: "Logged in successfully"}));
            } else {
                var t = (request.session.login != undefined && "tries" in request.session.login)?(request.session.login.tries+1):1;
                request.session.login = {valid: false, tries: t, when: Date.now()};
                return response.status(400).send(JSON.stringify({success: false, message: "Email/password combo was incorrect"}));
            }
        }
    });
});

app.get('/alive', function(request, response){
  return response.send('yes thank you');
});

app.route('/listing')
    .post(function(request, response) {
        response.set('Content-Type', 'application/json');
        if (request.body == undefined || request.body.type == undefined) {
          return response.status(400).send(JSON.stringify({success: false, message: "No listing type found in request"}));
        }
        if (request.body.type == 'other') {
          var listing = new MiscListing;
          listing.title = request.body.Title;
          listing.description = request.body.Description;
          listing.price = request.body.Price;
          console.log(JSON.stringify(request.body));
        }
        else if (request.body.type == 'sublet') {
          var listing = new SubletListing;
          listing.address = request.body.address;
          listing.date_range = request.body.date_range;
          listing.rent = request.body.rent;
          listing.bedrooms_available = request.body.bedrooms;
          listing.bathrooms = request.body.bathrooms;
          listing.image_gallery_link = ('image_gallery_link' in request.body) ? request.body.image_gallery_link : "";
          listing.est_utilities = ('est_utilities' in request.body) ? request.body.est_utilities : "";
          listing.notes = ('notes' in request.body) ? request.body.notes : "";
        }

        listing.user_id = 0;
        listing.save(function(err){
            if (!err) {
                return response.status(200).send(JSON.stringify({success: true, rsc_id: listing._id}));
            } else {
                return response.status(400).send(JSON.stringify({success: false, message:err}));
            }
        });
    })
    .get(function(request,response){
      response.set('Content-Type', 'application/json');
         return Listing.find(function (err, listings) {
            if (!err){
              return response.send(listings.reverse());
            } else {
              return response.send('{}');
            }
        });
    });

app.get('/search/:vars/:val', function(request,response){
  response.set('Content-Type', 'application/json');
	var val = request.params.val;
	return Listing.find({_id:val}, function (err, listing) {
	    if (!err){
	      response.send(listing);
	    } else {
	      response.send('{}');
	    }
	});
});

app.get('/listing/:uid', function(request,response){
  response.set('Content-Type', 'application/json');
	var uid = request.params.uid;
	return Listing.find({_id:uid}, function (err, listing) {
	    if (!err){
	      response.send(listing);
	    } else {
	      response.send('{}');
	    }
	});
});

app.delete('/listing/:uid', function(request,response){
  response.set('Content-Type', 'application/json');
	var uid = request.params.uid;
	return Listing.findOneAndRemove({_id:uid}).remove(function (err, listing) {
	    if (!err){
	      response.send(listing);
	    } else {
	      response.send(err);
	    }
	});
});

// catch 404 and forward to error handler
app.use(function(req, res, next) {
  var err = new Error('Not Found');
  err.status = 404;
  next(err);
});

// error handlers

// development error handler
// will print stacktrace
if (app.get('env') === 'development') {
  app.use(function(err, req, res, next) {
    res.status(err.status || 500);
    res.render('error', {
      message: err.message,
      error: err
    });
  });
}

// production error handler
// no stacktraces leaked to user
app.use(function(err, req, res, next) {
  res.status(err.status || 500);
  res.render('error', {
    message: err.message,
    error: {}
  });
});

app.listen(process.env.PORT || 80);

module.exports = app;
